<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Math — Dashboard</title>
  <link rel="stylesheet" href="assets/app.css">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="assets/supabaseClient.js"></script>
  <script src="assets/api.js"></script>
</head>
<body>
<header style="display:flex;align-items:center;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
  <h1>Math — Lessons</h1>

  <div style="display:flex;align-items:center;gap:.5rem;">
    <label for="lesson-filter">Show:</label>
    <select id="lesson-filter">
      <option value="all">All</option>
      <option value="completed">Completed only</option>
      <option value="pending">Not completed only</option>
    </select>
  </div>

  <div id="auth"></div>
</header>

<main id="content" class="card">
  <ul id="lessons">Loading…</ul>
</main>

<p class="muted">Parent? Visit <a href="parent.html">Parent dashboard</a>.</p>

<script>
(async () => {
  const authEl   = document.getElementById('auth');
  const listEl   = document.getElementById('lessons');
  const filterEl = document.getElementById('lesson-filter');

  // ----- Auth -----
  const ctx = await sb.currentUserWithProfile();

  if (!ctx) {
    authEl.innerHTML = `
      <input id="email" type="text" placeholder="Email" autocapitalize="none" autocomplete="username">
      <input id="password" type="password" placeholder="Password" autocomplete="current-password">
      <button class="primary" id="login">Login</button>
    `;

    const doLogin = async () => {
      const btn = document.getElementById('login');
      const email = document.getElementById('email').value.trim();
      const password = document.getElementById('password').value;
      if (!email || !password) { alert("Enter both email and password"); return; }
      btn.disabled = true;
      const user = await api.signInWithPassword(email, password);
      if (user) location.reload();
      btn.disabled = false;
    };

    document.getElementById('login').onclick = doLogin;
    document.getElementById('password').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') doLogin();
    });

    listEl.innerHTML = '<li>Sign in to view assignments.</li>';
    return;
  } else {
    authEl.innerHTML = `<span>${ctx.profile?.display_name ?? 'User'}</span> <button id="logout">Sign out</button>`;
    document.getElementById('logout').onclick = api.signOut;
  }

  const userId = ctx.user.id;

  // ----- Load lessons + attempts -----
  // If you want students to only see their assignments, swap to:
  //   const lessonsRaw = await api.listLessonsAssignedToCurrentUser();
  const lessonsRaw = await api.listAllLessonsForSite();
  const attempts   = await api.listAttemptsForUserAll(userId);

  // Build completion + best score maps
  const completedSet = new Set(
    (attempts || []).filter(a => !!a.submitted_at).map(a => a.lesson_id)
  );

  const bestScoreByLesson = (attempts || []).reduce((m, a) => {
    const cur = m.get(a.lesson_id) ?? 0;
    const s = typeof a.score === 'number' ? a.score : 0;
    if (s > cur) m.set(a.lesson_id, s);
    return m;
  }, new Map());

  // ----- Filter to lessons whose files exist in Storage (fast list-based) -----
  // We expect lesson.md_path and lesson.quiz_path to be storage paths like:
  //   "lessons/lesson-69.md" and "quizzes/lesson-69.json" (folder can vary)
  const BUCKET = 'content'; // adjust if your bucket name is different

  // Group lessons by directory so we can list each folder once
  const byDir = new Map(); // dirPath -> array of lessons touching that dir
  for (const L of lessonsRaw) {
    const mdDir = dirOf(L.md_path);
    const qzDir = dirOf(L.quiz_path);
    if (!byDir.has(mdDir)) byDir.set(mdDir, []);
    if (!byDir.has(qzDir)) byDir.set(qzDir, []);
    byDir.get(mdDir).push(L);
    if (qzDir !== mdDir) byDir.get(qzDir).push(L);
  }

  // List each directory and collect filenames into a Set for O(1) existence checks
  const existingByDir = new Map(); // dir -> Set(filenames)
  for (const dir of byDir.keys()) {
    const names = await listAllNamesInFolder(BUCKET, dir);
    existingByDir.set(dir, names);
  }

  // Keep only lessons where both md + json exist
  const lessons = lessonsRaw.filter(L => {
    const mdD = dirOf(L.md_path), mdN = nameOf(L.md_path);
    const qD  = dirOf(L.quiz_path), qN = nameOf(L.quiz_path);
    const mdOk = (existingByDir.get(mdD) || new Set()).has(mdN);
    const qOk  = (existingByDir.get(qD)  || new Set()).has(qN);
    return mdOk && qOk;
  });

  // ----- Filter UI state -----
  filterEl.value = localStorage.getItem('lessonFilter') || 'pending';

  function applyFilter(mode) {
    if (mode === 'completed') return lessons.filter(L => completedSet.has(L.id));
    if (mode === 'pending')   return lessons.filter(L => !completedSet.has(L.id));
    return lessons.slice();
  }

  function render(mode) {
    const view = applyFilter(mode);

    if (!view.length) {
      listEl.innerHTML = '<li>No lessons found.</li>';
      return;
    }

    listEl.innerHTML = view.map(L => {
      const done = completedSet.has(L.id);
      const best = bestScoreByLesson.get(L.id) ?? 0;

      return `
        <li style="display:flex;align-items:center;justify-content:space-between;gap:1rem;margin:.25rem 0;">
          <span>
            <a href="lesson.html?slug=${encodeURIComponent(L.slug)}">${L.title}</a>
            <small class="muted"> — for ${L.for_user}</small>
          </span>
          <span style="display:flex;align-items:center;gap:.5rem;">
            ${done ? `<span title="Completed">✅</span>` : ``}
            ${best ? `<span class="badge">${best}%</span>` : ``}
            <a class="button" href="lesson.html?slug=${encodeURIComponent(L.slug)}">Open</a>
          </span>
        </li>
      `;
    }).join('');
  }

  // initial render + wire change
  render(filterEl.value);
  filterEl.addEventListener('change', () => {
    localStorage.setItem('lessonFilter', filterEl.value);
    render(filterEl.value);
  });

  // ----- Helpers -----
  function dirOf(path) {
    const i = path.lastIndexOf('/');
    return i === -1 ? '' : path.slice(0, i); // '' = root of bucket
    // e.g., "lessons/grade6" -> "lessons/grade6"
  }
  function nameOf(path) {
    const i = path.lastIndexOf('/');
    return i === -1 ? path : path.slice(i + 1); // e.g., "lesson-69.md"
  }

  // List ALL filenames in a folder (handles pagination)
  async function listAllNamesInFolder(bucket, folder) {
    // Supabase Storage 'list' is not recursive; we list exactly this folder.
    // If you have nested folders deeper than one level, make sure folder is the exact parent.
    const names = new Set();
    const pageSize = 100;
    let offset = 0;
    while (true) {
      const { data, error } = await sb.supabase
        .storage
        .from(bucket)
        .list(folder || '', { limit: pageSize, offset, sortBy: { column: 'name', order: 'asc' } });
      if (error) {
        console.warn('Storage list error for', folder, error.message);
        break;
      }
      (data || []).forEach(entry => {
        // We only care about files (not subfolders)
        if (entry && !entry.id && entry.name) {
          names.add(entry.name);
        } else if (entry && entry.name && entry.metadata && entry.metadata.size >= 0) {
          names.add(entry.name); // newer sdk uses metadata for files
        }
      });
      if (!data || data.length < pageSize) break; // no more pages
      offset += pageSize;
    }
    return names;
  }
})();
</script>
</body>
</html>
